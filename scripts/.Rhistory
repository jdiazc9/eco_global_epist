library(gridExtra)
library(tidyverse)
library(cowplot)
# set seed for reproducibility
set.seed(0)
# load data sets
files <- list.files('../data_sets', full.names = T)
data <- lapply(files, FUN = function(file) read.csv(file))
# wrapper function: leave part of the data as out_of_sample, fit FEEs with the remaining data, use method to predict function and compare to observed function
pred_vs_obs <- function(data, f_out_of_sample = 0.2) {
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
fits <- makeFEEs(ge_data)
eps <- inferAllResiduals(ge_data)
# use method to predict the function of the out of sample communities
predicted_f <- predictF_fullClosure(out_of_sample$community,
data,
eps)
pred_obs <- merge(out_of_sample, predicted_f, by = 'community', suffixes = c('_obs', '_pred'))
r_squared <- cor(pred_obs$fun_obs, pred_obs$fun_pred)^2
return(list(df = pred_obs,
r_squared = r_squared))
}
i <- 3 #for (i in 1:5) {
# for the phytoplankton biomass dataset (Ghedini et al., scale functions by 1e-4 for easier readability)
if (i == 3) data[[i]][, ncol(data[[i]])] <- data[[i]][, ncol(data[[i]])]/1e4
# get predicted vs observed plots and r_squared (repeat 50 times for every data set)
po <- data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0))
r_squared <- NULL
po_i <- pred_vs_obs(data[[i]])
po <- rbind(po, po_i$df)
r_squared <- c(r_squared, po_i$r_squared)
po_i <- pred_vs_obs(data[[i]])
po <- rbind(po, po_i$df)
r_squared <- c(r_squared, po_i$r_squared)
rm(list = ls())
# load auxiliary functions
source('./ecoFunctions.R')
library(scales)
library(gridExtra)
library(tidyverse)
library(cowplot)
# set seed for reproducibility
set.seed(0)
# load data sets
files <- list.files('../data_sets', full.names = T)
data <- lapply(files, FUN = function(file) read.csv(file))
# wrapper function: leave part of the data as out_of_sample, fit FEEs with the remaining data, use method to predict function and compare to observed function
pred_vs_obs <- function(data, f_out_of_sample = 0.2) {
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
fits <- makeFEEs(ge_data)
eps <- inferAllResiduals(ge_data)
# use method to predict the function of the out of sample communities
predicted_f <- predictF_fullClosure(out_of_sample$community,
data,
eps)
pred_obs <- merge(out_of_sample, predicted_f, by = 'community', suffixes = c('_obs', '_pred'))
r_squared <- cor(pred_obs$fun_obs, pred_obs$fun_pred)^2
return(list(df = pred_obs,
r_squared = r_squared))
}
i <- 3 #for (i in 1:5) {
# for the phytoplankton biomass dataset (Ghedini et al., scale functions by 1e-4 for easier readability)
if (i == 3) data[[i]][, ncol(data[[i]])] <- data[[i]][, ncol(data[[i]])]/1e4
# get predicted vs observed plots and r_squared (repeat 50 times for every data set)
po <- data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0))
r_squared <- NULL
for (n in 1:50) {
print(c(i, n))
po_i <- pred_vs_obs(data[[i]])
po <- rbind(po, po_i$df)
r_squared <- c(r_squared, po_i$r_squared)
}
rm(list = ls())
# load auxiliary functions
source('./ecoFunctions.R')
library(scales)
library(gridExtra)
library(tidyverse)
library(cowplot)
# set seed for reproducibility
set.seed(0)
# load data sets
files <- list.files('../data_sets', full.names = T)
data <- lapply(files, FUN = function(file) read.csv(file))
# wrapper function: leave part of the data as out_of_sample, fit FEEs with the remaining data, use method to predict function and compare to observed function
pred_vs_obs <- function(data, f_out_of_sample = 0.2) {
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
fits <- makeFEEs(ge_data)
eps <- inferAllResiduals(ge_data)
# use method to predict the function of the out of sample communities
predicted_f <- predictF_fullClosure(out_of_sample$community,
data,
eps)
pred_obs <- merge(out_of_sample, predicted_f, by = 'community', suffixes = c('_obs', '_pred'))
r_squared <- cor(pred_obs$fun_obs, pred_obs$fun_pred)^2
return(list(df = pred_obs,
r_squared = r_squared))
}
i <- 3 #for (i in 1:5) {
# for the phytoplankton biomass dataset (Ghedini et al., scale functions by 1e-4 for easier readability)
if (i == 3) data[[i]][, ncol(data[[i]])] <- data[[i]][, ncol(data[[i]])]/1e4
# get predicted vs observed plots and r_squared (repeat 50 times for every data set)
po <- data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0))
r_squared <- NULL
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
rm(list = ls())
# load auxiliary functions
source('./ecoFunctions.R')
library(scales)
library(gridExtra)
library(tidyverse)
library(cowplot)
# set seed for reproducibility
set.seed(0)
# load data sets
files <- list.files('../data_sets', full.names = T)
data <- lapply(files, FUN = function(file) read.csv(file))
# wrapper function: leave part of the data as out_of_sample, fit FEEs with the remaining data, use method to predict function and compare to observed function
pred_vs_obs <- function(data, f_out_of_sample = 0.2) {
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
fits <- makeFEEs(ge_data)
eps <- inferAllResiduals(ge_data)
# use method to predict the function of the out of sample communities
predicted_f <- predictF_fullClosure(out_of_sample$community,
data,
eps)
pred_obs <- merge(out_of_sample, predicted_f, by = 'community', suffixes = c('_obs', '_pred'))
r_squared <- cor(pred_obs$fun_obs, pred_obs$fun_pred)^2
return(list(df = pred_obs,
r_squared = r_squared))
}
i <- 3 #for (i in 1:5) {
# for the phytoplankton biomass dataset (Ghedini et al., scale functions by 1e-4 for easier readability)
if (i == 3) data[[i]][, ncol(data[[i]])] <- data[[i]][, ncol(data[[i]])]/1e4
# get predicted vs observed plots and r_squared (repeat 50 times for every data set)
po <- data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0))
r_squared <- NULL
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
po_i <- pred_vs_obs(data[[i]])
data <- data[[i]]
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
View(ge_data)
fits <- makeFEEs(ge_data)
View(fits)
plotFEEs(ge_data)
View(po)
rm(list = ls())
# load auxiliary functions
source('./ecoFunctions.R')
library(scales)
library(gridExtra)
library(tidyverse)
library(cowplot)
# set seed for reproducibility
set.seed(0)
# load data sets
files <- list.files('../data_sets', full.names = T)
data <- lapply(files, FUN = function(file) read.csv(file))
# wrapper function: leave part of the data as out_of_sample, fit FEEs with the remaining data, use method to predict function and compare to observed function
pred_vs_obs <- function(data, f_out_of_sample = 0.2) {
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
fits <- makeFEEs(ge_data)
# make sure that all FEEs could be fitted (there is enough data in-sample for it), otherwise return NAs
if (any(is.na(fits[, 'b']))) {
return(list(df = data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0)),
r_squared = numeric(0)))
} else {
eps <- inferAllResiduals(ge_data)
# use method to predict the function of the out of sample communities
predicted_f <- predictF_fullClosure(out_of_sample$community,
data,
eps)
pred_obs <- merge(out_of_sample, predicted_f, by = 'community', suffixes = c('_obs', '_pred'))
r_squared <- cor(pred_obs$fun_obs, pred_obs$fun_pred)^2
return(list(df = pred_obs,
r_squared = r_squared))
}
}
i <- 3 #for (i in 1:5) {
# for the phytoplankton biomass dataset (Ghedini et al., scale functions by 1e-4 for easier readability)
if (i == 3) data[[i]][, ncol(data[[i]])] <- data[[i]][, ncol(data[[i]])]/1e4
# get predicted vs observed plots and r_squared (repeat 50 times for every data set)
po <- data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0))
r_squared <- NULL
for (n in 1:50) {
print(c(i, n))
po_i <- pred_vs_obs(data[[i]])
po <- rbind(po, po_i$df)
r_squared <- c(r_squared, po_i$r_squared)
}
r_squared
mean(r_sqaured)
mean(r_squared)
po_i <- po_i$df
range <- c(min(c(po_i$predicted_f, po_i$fun)),
max(c(po_i$predicted_f, po_i$fun)))
View(po_i)
min(c(po_i$predicted_f, po_i$fun))
View(po_i)
range <- c(min(c(po_i$fun_obs, po_i$fun_pred)),
max(c(po_i$fun_obs, po_i$fun_pred)))
range
ggplot(po_i, aes(x = fun_pred, y = fun_obs)) +
geom_abline(slope = 1,
intercept = 0,
color = '#d1d3d4') +
geom_point(shape = 1,
cex = 3)
ggplot(po_i, aes(x = fun_pred, y = fun_obs)) +
geom_abline(slope = 1,
intercept = 0,
color = '#d1d3d4') +
geom_point(shape = 1,
cex = 3) +
scale_x_continuous(breaks = pretty_breaks(n = 3),
name = expression(paste('Predicted ', italic('F'), ' [a.u.]', sep = '')),
limits = range) +
scale_y_continuous(breaks = pretty_breaks(n = 3),
name = expression(paste('Observed ', italic('F'), ' [a.u.]', sep = '')),
limits = range) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(face = 'italic',
size = 10),
aspect.ratio = 0.6,
axis.text = element_text(size = 16),
axis.title = element_text(size = 18),
panel.border = element_blank(),
panel.background = element_blank(),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
max(r_squared)
source("~/projects/eco_global_epist/scripts/figS2.R", echo=TRUE)
r_squared
rm(list = ls())
# load auxiliary functions
source('./ecoFunctions.R')
library(scales)
library(gridExtra)
library(tidyverse)
library(cowplot)
# set seed for reproducibility
set.seed(1)
# load data sets
files <- list.files('../data_sets', full.names = T)
data <- lapply(files, FUN = function(file) read.csv(file))
# wrapper function: leave part of the data as out_of_sample, fit FEEs with the remaining data, use method to predict function and compare to observed function
pred_vs_obs <- function(data, f_out_of_sample = 0.2) {
# average replicates
data <- matrix2string(data)
data <- aggregate(formula = fun ~ .,
data = data,
FUN = mean)
# leave 20% of data out-of-sample
which_out_of_sample <- sample(1:nrow(data), size = round(0.3*nrow(data)))
out_of_sample <- data[which_out_of_sample, ]
data <- data[-which_out_of_sample, ]
# make sure the 'empty' community is left in sample
empty_comm <- which(out_of_sample$community == '')
if (length(empty_comm)) {
data <- rbind(data, out_of_sample[empty_comm, ])
out_of_sample <- out_of_sample[-empty_comm, ]
}
# fit FEEs with the remaining data
ge_data <- makeGEdata(data)
fits <- makeFEEs(ge_data)
# make sure that all FEEs could be fitted (there is enough data in-sample for it), otherwise return NAs
if (any(is.na(fits[, 'b']))) {
return(list(df = data.frame(community = character(0),
fun = numeric(0),
predicted_f = numeric(0)),
r_squared = numeric(0)))
} else {
eps <- inferAllResiduals(ge_data)
# use method to predict the function of the out of sample communities
predicted_f <- predictF_fullClosure(out_of_sample$community,
data,
eps)
pred_obs <- merge(out_of_sample, predicted_f, by = 'community', suffixes = c('_obs', '_pred'))
r_squared <- cor(pred_obs$fun_obs, pred_obs$fun_pred)^2
return(list(df = pred_obs,
r_squared = r_squared))
}
}
i <- 3 #for (i in 1:5) {
# for the phytoplankton biomass dataset (Ghedini et al., scale functions by 1e-4 for easier readability)
if (i == 3) data[[i]][, ncol(data[[i]])] <- data[[i]][, ncol(data[[i]])]/1e4
# get predicted vs observed plots and r_squared (repeat 50 times for every data set)
po <- data.frame(run = numeric(0),
community = character(0),
fun_obs = numeric(0),
fun_pred = numeric(0))
r_squared <- NULL
for (n in 1:50) {
print(c(i, n))
po_i <- pred_vs_obs(data[[i]])
po <- rbind(po, cbind(data.frame(run = rep(n, nrow(po_i$df))),
po_i$df))
r_squared <- c(r_squared, po_i$r_squared)
}
View(po)
which_run <- which.min(r_squared - 0.75)
which_run
?which.min
which.min(c(0,1,2))
which.min(c(0,1,2,NA))
po_i <- po[po$run == which.min(r_squared - 0.75, )]
po_i <- po[po$run == which.min(r_squared - 0.75)]
po_i <- po[po$run == which.min(r_squared - 0.75), ]
range <- c(min(c(po_i$fun_obs, po_i$fun_pred)),
max(c(po_i$fun_obs, po_i$fun_pred)))
# plot
plot1 <-
ggplot(po_i, aes(x = fun_pred, y = fun_obs)) +
geom_abline(slope = 1,
intercept = 0,
color = '#d1d3d4') +
geom_point(shape = 1,
cex = 3) +
scale_x_continuous(breaks = pretty_breaks(n = 3),
name = expression(paste('Predicted ', italic('F'), ' [a.u.]', sep = '')),
limits = range) +
scale_y_continuous(breaks = pretty_breaks(n = 3),
name = expression(paste('Observed ', italic('F'), ' [a.u.]', sep = '')),
limits = range) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(face = 'italic',
size = 10),
aspect.ratio = 0.6,
axis.text = element_text(size = 16),
axis.title = element_text(size = 18),
panel.border = element_blank(),
panel.background = element_blank(),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
print(plot1)
po_i
cor(po_i$fun_obs, po_i$fun_pred)
cor(po_i$fun_obs, po_i$fun_pred)^2
r_squared[4]
po_i <- po[po$run == which.min(abs(r_squared - 0.75)), ]
range <- c(min(c(po_i$fun_obs, po_i$fun_pred)),
max(c(po_i$fun_obs, po_i$fun_pred)))
po_i
which.min(abs(r_squared - 0.75))
po
unique(po$run)
length(unique(po$run))
unique(po$run)[34]
which.min(abs(r_squared - 0.75))
unique(po$run)[12]
po_i <- po[po$run == unique(po$run)[which.min(abs(r_squared - 0.75))], ]
range <- c(min(c(po_i$fun_obs, po_i$fun_pred)),
max(c(po_i$fun_obs, po_i$fun_pred)))
# plot
plot1 <-
ggplot(po_i, aes(x = fun_pred, y = fun_obs)) +
geom_abline(slope = 1,
intercept = 0,
color = '#d1d3d4') +
geom_point(shape = 1,
cex = 3) +
scale_x_continuous(breaks = pretty_breaks(n = 3),
name = expression(paste('Predicted ', italic('F'), ' [a.u.]', sep = '')),
limits = range) +
scale_y_continuous(breaks = pretty_breaks(n = 3),
name = expression(paste('Observed ', italic('F'), ' [a.u.]', sep = '')),
limits = range) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(face = 'italic',
size = 10),
aspect.ratio = 0.6,
axis.text = element_text(size = 16),
axis.title = element_text(size = 18),
panel.border = element_blank(),
panel.background = element_blank(),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
print(plot1)
source("~/projects/eco_global_epist/scripts/figS2.R", echo=TRUE)

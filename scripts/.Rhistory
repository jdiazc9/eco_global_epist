color = 'black',
fullrange = T,
se = F) +
# geom_abline(data = plot_this,
#             aes(slope = slope, intercept = intercept)) +
geom_abline(data = plot_this,
aes(slope = expected_slope, intercept = expected_intercept),
linetype = 'dashed') +
facet_wrap(~species,
ncol = 1,
scales = 'free')
View(plot_this)
ge_data_i <- makeGEdata(matrix2string(data[[1]]))
ge_data_i <- ge_data_i[ge_data_i$knock_in == 'P', ]
ge_data_i$branch <- grapl('T', ge_data_i$background)
ge_data_i$branch <- grEpl('T', ge_data_i$background)
ge_data_i$branch <- grepl('T', ge_data_i$background)
ge_data_i <- makeGEdata(matrix2string(data[[1]]))
ge_data_i <- ge_data_i[ge_data_i$knock_in == 'P', ]
ge_data_i$branch <- grepl('T', ge_data_i$background)
ge_data_i <- rbind(ge_data_i, cbind(ge_data[[4]], branch = F))
ge_data_i <- rbind(ge_data_i, cbind(ge_data[[5]], branch = F))
ge_data_i <- ge_data_i[ge_data_i$knock_in %in% c('fa.nat', 'SL106', 'P. polymyxa'), ]
ge_data_i <- makeGEdata(matrix2string(data[[1]]))
ge_data_i <- ge_data_i[ge_data_i$knock_in == 'P', ]
ge_data_i$branch <- grepl('T', ge_data_i$background)
ge_data_i <- rbind(ge_data_i, cbind(ge_data[[4]], branch = F))
ge_data_i <- rbind(ge_data_i, cbind(ge_data[[5]], branch = F))
ge_data_i <- ge_data_i[ge_data_i$knock_in %in% c('fa.nat', 'SL106', 'P'), ]
ge_data_i$knock_in <- sp_names[ge_data_i$knock_in]
colnames(ge_data_i)[2] <- 'species'
ge_data_i$species <- factor(ge_data_i$species,
levels = c('P. polymyxa',
'Sphingoterrabacterium sp.',
'L. capitata'))
lims <- data.frame(species = rep(levels(ge_data_i$species), 2),
background_f = c(20, 1.5, 5.5, 0, 0.5, 0),
d_f = c(32, 1.2, 12, -8, -0.25, -3))
lims$species <- factor(lims$species, levels = levels(ge_data_i$species))
lims <- rbind(cbind(lims, branch = T),
cbind(lims, branch = F))
plot_this$species <- factor(plot_this$species, levels = levels(ge_data_i$species))
ggplot(ge_data_i, aes(x = background_f, y = d_f, color = branch)) +
geom_abline(slope = 0,
intercept = 0,
color = '#d1d3d4') +
geom_point(color = 'black',
shape = 1,
cex = 3) +
geom_point(data = lims,
color = 'white',
shape = 3) +
geom_smooth(formula = y ~ x,
method = 'lm',
color = 'black',
fullrange = T,
se = F) +
# geom_abline(data = plot_this,
#             aes(slope = slope, intercept = intercept)) +
geom_abline(data = plot_this,
aes(slope = expected_slope, intercept = expected_intercept),
linetype = 'dashed') +
facet_wrap(~species,
ncol = 1,
scales = 'free')
View(ge_data_i)
ggplot(ge_data_i, aes(x = background_f, y = d_f, group = branch)) +
geom_abline(slope = 0,
intercept = 0,
color = '#d1d3d4') +
geom_point(color = 'black',
shape = 1,
cex = 3) +
geom_point(data = lims,
color = 'white',
shape = 3) +
geom_smooth(formula = y ~ x,
method = 'lm',
color = 'black',
fullrange = T,
se = F) +
# geom_abline(data = plot_this,
#             aes(slope = slope, intercept = intercept)) +
geom_abline(data = plot_this,
aes(slope = expected_slope, intercept = expected_intercept),
linetype = 'dashed') +
facet_wrap(~species,
ncol = 1,
scales = 'free')
ggplot(ge_data_i, aes(x = background_f, y = d_f, group = branch)) +
geom_abline(slope = 0,
intercept = 0,
color = '#d1d3d4') +
geom_point(color = 'black',
shape = 1,
cex = 3) +
geom_point(data = lims,
color = 'white',
shape = 3) +
geom_smooth(formula = y ~ x,
method = 'lm',
color = 'black',
fullrange = F,
se = F) +
# geom_abline(data = plot_this,
#             aes(slope = slope, intercept = intercept)) +
geom_abline(data = plot_this,
aes(slope = expected_slope, intercept = expected_intercept),
linetype = 'dashed') +
facet_wrap(~species,
ncol = 1,
scales = 'free')
ggplot(ge_data_i, aes(x = background_f, y = d_f, group = branch)) +
geom_abline(slope = 0,
intercept = 0,
color = '#d1d3d4') +
geom_point(color = 'black',
shape = 1,
cex = 3) +
geom_point(data = lims,
color = 'white',
shape = 3) +
geom_smooth(formula = y ~ x,
method = 'lm',
color = 'black',
fullrange = F,
se = F) +
# geom_abline(data = plot_this,
#             aes(slope = slope, intercept = intercept)) +
geom_abline(data = plot_this,
aes(slope = expected_slope, intercept = expected_intercept),
linetype = 'dashed') +
facet_wrap(~species,
ncol = 1,
scales = 'free') +
scale_x_continuous(name = expression(paste(italic(F), ' (background) [a.u.]', sep = '')),
breaks = pretty_breaks(n = 3)) +
scale_y_continuous(name = expression(paste(Delta, italic(F), ' [a.u.]', sep = '')),
breaks = pretty_breaks(n = 2)) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(face = 'italic',
size = 16,
hjust = 0),
aspect.ratio = 0.6,
axis.text = element_text(size = 14),
axis.title = element_text(size = 18),
panel.border = element_blank(),
panel.background = element_blank(),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
ggsave(filename = '../plots/fees_expvstheory_samples.pdf',
device = 'pdf',
dpi = 600,
width = 100,
height = 150,
units = 'mm',
limitsize = F)
source("Z:/work/micro-eco/ge_paper_v2/eco_global_epist/scripts/slopes_theory_vs_exp.R", echo=TRUE)
library(tidyverse)
library(glmnet)
library(cowplot)
source('ecoFunctions.R')
rm(list = ls())
library(tidyverse)
library(glmnet)
library(cowplot)
source('ecoFunctions.R')
#metric
get_rmse <- function(observed, predicted){
return(sqrt(sum((observed - predicted)^2)/length(observed)))
}
#helper function for cross-validated regression
get_folds <- function(df, unique_communities, n_folds = 10){
n_points <- length(unique_communities)
base_fold_size <- floor(n_points/n_folds)
rem_fold_size <- floor(n_points %% n_folds)
diff <- n_folds - rem_fold_size
if (diff != n_folds){
full_sample <- c(rep(seq(1:diff), base_fold_size), rep((diff + 1): n_folds, base_fold_size + 1))
} else {
full_sample <- rep(seq(1:n_folds), base_fold_size)
}
fold_sample <- sample(full_sample, size = length(full_sample), replace = FALSE)
fold_data <- data.frame(community = unique_communities, fold_id = fold_sample)
fold_id_data <- left_join(df, fold_data, by = 'community')
fold_ids <- fold_id_data$fold_id
return(fold_ids)
}
get_all_loo_fits <- function(df, v = FALSE){
N <- ncol(df) -1
all_species <- colnames(df)[1:N]
communities <- sapply(1:nrow(df),
FUN = function(i) paste(all_species[df[i, -ncol(df)] == 1], collapse = ','))
unique_communities <- unique(communities)
df <- df %>% mutate(community = communities)
#add mean fitness to df
df <- df %>% group_by(community) %>% mutate(mean_fitness = mean(fitness)) %>% ungroup()
mean_df <- df %>% distinct(community, .keep_all = TRUE) %>% dplyr::select(-c(fitness))
####################
#### stitching #####
####################
loo_res <- tibble()
for (exp in unique_communities){
exp_inds <- which(mean_df$community == exp)
data <- mean_df[-exp_inds,] %>% dplyr::select(-community)
if (! any(rowSums(mean_df[,1:N]) == 0)){
data <- rbind(data, rep(0, (N + 1)))
}
obsF <- mean_df[exp_inds[1],] %>% dplyr::select(-community)
target <- matrix2string(obsF)
data <- matrix2string(data)
ge_data <- makeGEdata(data)
eps <- try(inferAllResiduals(ge_data))
predF <- predictF_fullClosure(target$community, data, eps)
po <- merge(target, predF, by = 'community', suffixes = c('_obs', '_pred'))
colnames(po) <- c('community', 'observed', 'predicted')
tmp <- list(obs = po$observed, pred = po$predicted)
loo_res <- rbind(loo_res, tmp)
}
#################################
# first order linear regression #
#################################
loo_res_first_order <- tibble()
for (exp in unique_communities){
exp_inds <- which(df$community == exp)
#set up regression
y <- as.matrix(df[-exp_inds,]$fitness)
f <- as.formula(y ~ .)
x <- model.matrix(f, df[-exp_inds,] %>% dplyr::select(all_of(all_species)))
unique_communities_train <- unique_communities[-which(unique_communities == exp)]
fold_ids <- get_folds(df[-exp_inds,], unique_communities_train, n_folds = 10)
cv_fit <- cv.glmnet(x = x, y = y, foldid = fold_ids)
#get out of fit cv
y_test <- as.matrix(df[exp_inds[1],]$fitness)
f_test <- as.formula(y_test ~ .)
x_test <- model.matrix(f_test, df[exp_inds[1],] %>% dplyr::select(all_of(all_species)))
y_pred_cv <- predict(cv_fit, x_test, s = "lambda.1se" )
tmp <- list(obs = df[exp_inds[1],]$mean_fitness, pred = y_pred_cv)
loo_res_first_order <- rbind(loo_res_first_order, tmp)
}
#################################
# second order linear regression #
#################################
count <- 1
loo_res_second_order <- tibble()
for (exp in unique_communities){
if (v){
print(paste0(count , ' out of ', length(unique_communities)))
count <- count + 1
}
exp_inds <- which(df$community == exp)
#set up regression
y <- as.matrix(df[-exp_inds,]$fitness)
f <- as.formula(y ~ .*.)
x <- model.matrix(f, df[-exp_inds,] %>% dplyr::select(all_of(all_species)))
unique_communities_train <- unique_communities[-which(unique_communities == exp)]
fold_ids <- get_folds(df[-exp_inds,], unique_communities_train, n_folds = 10)
cv_fit <- cv.glmnet(x = x, y = y, foldid = fold_ids)
#get out of fit cv
y_test <- as.matrix(df[exp_inds[1],]$fitness)
f_test <- as.formula(y_test ~ .*.)
x_test <- model.matrix(f_test, df[exp_inds[1],] %>% dplyr::select(all_of(all_species)))
y_pred_cv <- predict(cv_fit, x_test, s = "lambda.1se" )
tmp <- list(obs = df[exp_inds[1],]$mean_fitness, pred = y_pred_cv)
loo_res_second_order <- rbind(loo_res_second_order, tmp)
}
r2 <- cor(loo_res$obs, loo_res$pred)^2
r2_first_order <- cor(loo_res_first_order$obs, loo_res_first_order$pred)^2
r2_second_order <- cor(loo_res_second_order$obs, loo_res_second_order$pred)^2
return(list(r2 = r2, r2_first_order = r2_first_order, r2_second_order = r2_second_order,
loo_res = loo_res, loo_res_first_order = loo_res_first_order,
loo_res_second_order = loo_res_second_order))
}
fit_all_models_oof <- function(df, N, reps, v = FALSE){
res <- tibble()
all_species <- colnames(df)[1:N]
communities <- sapply(1:nrow(df),
FUN = function(i) paste(all_species[df[i, -ncol(df)] == 1], collapse = ','))
unique_communities <- unique(communities)
df <- df %>% mutate(community = communities)
#add mean fitness to df
df <- df %>% group_by(community) %>% mutate(mean_fitness = mean(fitness)) %>% ungroup()
mean_df <- df %>% distinct(community, .keep_all = TRUE) %>% dplyr::select(-c(fitness))
infit_range <- c(.6, .7, .8, .9)
for (infit_pct in infit_range){
for (i in 1:reps){
if (v == TRUE){print(paste0('infit pct is: ', infit_pct, 'rep: ', i))}
#get random training sample of communities
train_ids <- sample(1:length(unique_communities), (infit_pct) * length(unique_communities))
train <- which(df$community %in% unique_communities[train_ids])
train_stitching <- which(mean_df$community %in% unique_communities[train_ids])
data <- mean_df[train_stitching,] %>% dplyr::select(-community)
#need to add 0 community
data <- rbind(data, rep(0, (N + 1)))
#process data for stitching procedure
obsF <- mean_df[-train_stitching,] %>% dplyr::select(-community)
target <- matrix2string(obsF)
data <- matrix2string(data)
ge_data <- makeGEdata(data)
eps <- try(inferAllResiduals(ge_data))
#get stitching predictions
predF <- predictF_fullClosure(target$community, data, eps)
po <- merge(target, predF, by = 'community', suffixes = c('_obs', '_pred'))
colnames(po) <- c('community', 'observed', 'predicted')
#get stitching metrics
r2 <- cor(po$observed, po$predicted)^2
rmse_stitching <- get_rmse(po$observed, po$predicted)
#################################
# first order linear regression #
#################################
#set up regression
y <- as.matrix(df[train,]$fitness)
f <- as.formula(y ~ .)
x <- model.matrix(f, df[train,] %>% dplyr::select(all_of(all_species)))
unique_communities_train <- unique_communities[train_ids]
fold_ids <- get_folds(df[train,], unique_communities_train, n_folds = 10)
cv_fit <- cv.glmnet(x = x, y = y, foldid = fold_ids)
#get out of fit cv
y_test <- as.matrix(df[-train,]$fitness)
f_test <- as.formula(y_test ~ .)
x_test <- model.matrix(f_test, df[-train,] %>% dplyr::select(all_of(all_species)))
y_pred_cv <- predict(cv_fit, x_test, s = "lambda.1se" )
#bind predictions
all_pred <- df[-train,] %>% mutate(predicted = y_pred_cv[,1]) %>%
distinct(community, .keep_all = TRUE)
#get metrics cv
r2_lin <- cor(all_pred$mean_fitness, all_pred$predicted)^2
rmse_lin <- get_rmse(all_pred$mean_fitness, all_pred$predicted)
#################################
# second order linear regression #
#################################
y <- as.matrix(df[train,]$fitness)
f <- as.formula(y ~ .*.)
x <- model.matrix(f, df[train,] %>% dplyr::select(all_of(all_species)))
unique_communities_train <- unique_communities[train_ids]
fold_ids <- get_folds(df[train,], unique_communities_train, n_folds = 10)
cv_fit <- cv.glmnet(x = x, y = y, foldid = fold_ids)
#get out of fit cv
y_test <- as.matrix(df[-train,]$fitness)
f_test <- as.formula(y_test ~ .*.)
x_test <- model.matrix(f_test, df[-train, 1:N])
y_pred_cv <- predict(cv_fit, x_test, s = "lambda.1se" )
#bind predictions
all_pred <- df[-train,] %>% mutate(predicted = y_pred_cv[,1]) %>%
distinct(community, .keep_all = TRUE)
#get metrics cv
r2_cv_pairs <- cor(all_pred$mean_fitness, all_pred$predicted)^2
rmse_cv_pairs <- get_rmse(all_pred$mean_fitness, all_pred$predicted)
plot(po$observed, po$predicted, main = 'stitching pred')
abline(0,1)
plot(all_pred$mean_fitness, all_pred$predicted, main = 'cv pred')
abline(0,1)
#bind this all together
tmp <- list(r2 = r2, r2_lin = r2_lin, r2_cv_pairs = r2_cv_pairs,
rmse_stitching = rmse_stitching, rmse_lin = rmse_lin,
rmse_cv_pairs = rmse_cv_pairs,
infit_pct = infit_pct)
res <- rbind(res, tmp)
}
}
return(res)
}
#list all dataframe paths
path <- '~/global_epistasis_clean/Data/'
#list all dataframe paths
path <- '../data_sets'
all_datasets <- list.files(path = path)
all_datasets
list.files('../pyoverdine_data')
#list all dataframe paths
path <- '../data_sets'
all_datasets <- list.files(path = path)
# want GE_biomass, Kuebbing natives, langenheder, pyoverdine, starch
all_datasets <- all_datasets[c(2,3, 6,7,8,9)]
p_list <- list()
res <- tibble()
res
dataset_id <- 1
df <- read_csv(paste0(path, all_datasets[dataset_id]))
#list all dataframe paths
path <- '../data_sets/'
all_datasets <- list.files(path = path)
# want GE_biomass, Kuebbing natives, langenheder, pyoverdine, starch
all_datasets <- all_datasets[c(2,3, 6,7,8,9)]
p_list <- list()
res <- tibble()
df <- read_csv(paste0(path, all_datasets[dataset_id]))
df <- read_csv(paste0(path, all_datasets[dataset_id]), show_col_types = F)
View(df)
name <- str_remove(all_datasets[dataset_id], '.csv')
name
loo_fits <- get_all_loo_fits(df)
dataset_id <- 2
df <- read_csv(paste0(path, all_datasets[dataset_id]), show_col_types = F)
name <- str_remove(all_datasets[dataset_id], '.csv')
loo_fits <- get_all_loo_fits(df)
df <- read_csv(paste0(path, all_datasets[dataset_id]), show_col_types = F)
colnames(df)[ncol(df)] <- 'fitness'
name <- str_remove(all_datasets[dataset_id], '.csv')
if (name == 'starch_data'){
df <- df[-which(rowSums(df[,1:6]) == 0),]
}
loo_fits <- get_all_loo_fits(df)
View(df)
#list all dataframe paths
path <- '../data_sets/'
all_datasets <- list.files(path = path)
# want GE_biomass, Kuebbing natives, langenheder, pyoverdine, starch
all_datasets <- all_datasets[c(2,3, 6,7,8,9)]
p_list <- list()
res <- tibble()
df <- read_csv(paste0(path, all_datasets[dataset_id]), show_col_types = F)
colnames(df)
loo_fits <- get_all_loo_fits(df)
get_all_loo_fits <- function(df, v = FALSE){
N <- ncol(df) -1
all_species <- colnames(df)[1:N]
communities <- sapply(1:nrow(df),
FUN = function(i) paste(all_species[df[i, -ncol(df)] == 1], collapse = ','))
unique_communities <- unique(communities)
df <- df %>% mutate(community = communities)
#add mean fitness to df
df <- df %>% group_by(community) %>% mutate(mean_fitness = mean(`function`)) %>% ungroup()
mean_df <- df %>% distinct(community, .keep_all = TRUE) %>% dplyr::select(-c(fitness))
####################
#### stitching #####
####################
loo_res <- tibble()
for (exp in unique_communities){
exp_inds <- which(mean_df$community == exp)
data <- mean_df[-exp_inds,] %>% dplyr::select(-community)
if (! any(rowSums(mean_df[,1:N]) == 0)){
data <- rbind(data, rep(0, (N + 1)))
}
obsF <- mean_df[exp_inds[1],] %>% dplyr::select(-community)
target <- matrix2string(obsF)
data <- matrix2string(data)
ge_data <- makeGEdata(data)
eps <- try(inferAllResiduals(ge_data))
predF <- predictF_fullClosure(target$community, data, eps)
po <- merge(target, predF, by = 'community', suffixes = c('_obs', '_pred'))
colnames(po) <- c('community', 'observed', 'predicted')
tmp <- list(obs = po$observed, pred = po$predicted)
loo_res <- rbind(loo_res, tmp)
}
#################################
# first order linear regression #
#################################
loo_res_first_order <- tibble()
for (exp in unique_communities){
exp_inds <- which(df$community == exp)
#set up regression
y <- as.matrix(df[-exp_inds,]$fitness)
f <- as.formula(y ~ .)
x <- model.matrix(f, df[-exp_inds,] %>% dplyr::select(all_of(all_species)))
unique_communities_train <- unique_communities[-which(unique_communities == exp)]
fold_ids <- get_folds(df[-exp_inds,], unique_communities_train, n_folds = 10)
cv_fit <- cv.glmnet(x = x, y = y, foldid = fold_ids)
#get out of fit cv
y_test <- as.matrix(df[exp_inds[1],]$fitness)
f_test <- as.formula(y_test ~ .)
x_test <- model.matrix(f_test, df[exp_inds[1],] %>% dplyr::select(all_of(all_species)))
y_pred_cv <- predict(cv_fit, x_test, s = "lambda.1se" )
tmp <- list(obs = df[exp_inds[1],]$mean_fitness, pred = y_pred_cv)
loo_res_first_order <- rbind(loo_res_first_order, tmp)
}
#################################
# second order linear regression #
#################################
count <- 1
loo_res_second_order <- tibble()
for (exp in unique_communities){
if (v){
print(paste0(count , ' out of ', length(unique_communities)))
count <- count + 1
}
exp_inds <- which(df$community == exp)
#set up regression
y <- as.matrix(df[-exp_inds,]$fitness)
f <- as.formula(y ~ .*.)
x <- model.matrix(f, df[-exp_inds,] %>% dplyr::select(all_of(all_species)))
unique_communities_train <- unique_communities[-which(unique_communities == exp)]
fold_ids <- get_folds(df[-exp_inds,], unique_communities_train, n_folds = 10)
cv_fit <- cv.glmnet(x = x, y = y, foldid = fold_ids)
#get out of fit cv
y_test <- as.matrix(df[exp_inds[1],]$fitness)
f_test <- as.formula(y_test ~ .*.)
x_test <- model.matrix(f_test, df[exp_inds[1],] %>% dplyr::select(all_of(all_species)))
y_pred_cv <- predict(cv_fit, x_test, s = "lambda.1se" )
tmp <- list(obs = df[exp_inds[1],]$mean_fitness, pred = y_pred_cv)
loo_res_second_order <- rbind(loo_res_second_order, tmp)
}
r2 <- cor(loo_res$obs, loo_res$pred)^2
r2_first_order <- cor(loo_res_first_order$obs, loo_res_first_order$pred)^2
r2_second_order <- cor(loo_res_second_order$obs, loo_res_second_order$pred)^2
return(list(r2 = r2, r2_first_order = r2_first_order, r2_second_order = r2_second_order,
loo_res = loo_res, loo_res_first_order = loo_res_first_order,
loo_res_second_order = loo_res_second_order))
}
loo_fits <- get_all_loo_fits(df)
df
tst <- makeGEdata(df)
View(df)
colnames(df)[ncol(df)] <- 'fun'
tst <- makeGEdata(df)
colnames(df)[ncol(df)] <- 'function'
tst <- makeGEdata(matrix2string(df))
tst <- matrix2string(df)
View(tst)

data = df,
FUN = mean)
return(df)
})
data[[6]] <- rbind(data[[6]], data[[7]])
data <- data[1:6]
emp_ruggedness <- do.call(rbind,
lapply(1:length(data),
FUN = function(i) {
df <- data[[i]]
colnames(df)[ncol(df)] <- 'fun'
rs <- get_rs(df)
return(data.frame(dataset = basename(files)[i],
rs = rs))
}))
emp_ruggedness$dataset <- setNames(c('Bacterial starch hydrolysis',
'Bacterial butyrate secretion',
'Phytoplankton biomass',
'Above-ground plant biomass',
'Bacterial xylose oxidation',
'Bacterial pyoverdine secretion'),
basename(files)[1:6])[emp_ruggedness$dataset]
emp_ruggedness$dataset <- factor(emp_ruggedness$dataset, levels = c('Above-ground plant biomass',
'Phytoplankton biomass',
'Bacterial xylose oxidation',
'Bacterial starch hydrolysis',
'Bacterial butyrate secretion',
'Bacterial pyoverdine secretion'))
ggplot(tst[tst$rs > -1 & tst$rs < 1, ],
aes(x = rs, y = R2, color = prediction_method)) +
geom_point(alpha = 0.05) +
geom_vline(data = emp_ruggedness,
aes(xintercept = log10(rs), color = dataset),
linetype = 'dashed') +
geom_function(fun = myLogistic, args = list(A = mylns$A[2], B = mylns$B[2]),
color = mycolors[1],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[3], B = mylns$B[3]),
color = mycolors[2],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[1], B = mylns$B[1]),
color = mycolors[3],
linewidth = 1) +
scale_x_continuous(name = expression(paste('Ruggedness (', italic(r), '/', italic(s), ')')),
breaks = c(-1, 0, 1),
labels = c(expression(10^-1), expression(10^0), expression(10^1))) +
scale_y_continuous(name = expression(paste(italic(R)^2, ' predictions vs. observations')),
breaks = c(0, 0.5, 1)) +
scale_color_manual(name = '',
values = c(setNames(mycolors, levels(tst$prediction_method)),
setNames(c('#d6d62d',
'#66b666',
'#cb96c3',
'#d72027',
'#519ed7',
'black'),
levels(emp_ruggedness$dataset)))) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.text = element_text(size = 14),
legend.title = element_blank())
#heatmaps
mycolors <- c('#99d7dc', '#176766', '#b33a3b')
ggplot(tst[tst$rs > -1 & tst$rs < 1, ],
aes(x = rs, y = R2, color = prediction_method)) +
geom_point(alpha = 0.05) +
geom_vline(data = emp_ruggedness,
aes(xintercept = log10(rs), color = dataset),
linetype = 'dashed') +
geom_function(fun = myLogistic, args = list(A = mylns$A[2], B = mylns$B[2]),
color = mycolors[1],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[3], B = mylns$B[3]),
color = mycolors[2],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[1], B = mylns$B[1]),
color = mycolors[3],
linewidth = 1) +
scale_x_continuous(name = expression(paste('Ruggedness (', italic(r), '/', italic(s), ')')),
breaks = c(-1, 0, 1),
labels = c(expression(10^-1), expression(10^0), expression(10^1))) +
scale_y_continuous(name = expression(paste(italic(R)^2, ' predictions vs. observations')),
breaks = c(0, 0.5, 1)) +
scale_color_manual(name = '',
values = c(setNames(mycolors, levels(tst$prediction_method)),
setNames(c('#d6d62d',
'#66b666',
'#cb96c3',
'#d72027',
'#519ed7',
'black'),
levels(emp_ruggedness$dataset)))) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.text = element_text(size = 14),
legend.title = element_blank())
scale_coeffs <- function(coeff_order, mean_scale = 1, sd_scale = 2) {
if (coeff_order <= 1) return(1)
else return(0.2 + (1 - 0.2)*2^((coeff_order - 1)/(sd_scale)))
}
# variance by order plots
focal_sd_scale <- unique(params$sd_scale)[c(F, T, F, F, T, F, F, T, F, F, T, F)]
rel_var <- do.call(rbind,
lapply(focal_sd_scale,
FUN = function(x) {
data.frame(sd_scale = x,
coeff_order = 1:N,
rel_var = scale_coeffs(1:N, sd_scale = x)^2 / sum(scale_coeffs(1:N, sd_scale = x)^2))
}))
scale_coeffs <- function(coeff_order, mean_scale = 1, sd_scale = 2) sapply(coeff_order,
FUN = function(x) {
if (x <= 1) return(1)
else return(0.2 + (1 - 0.2)*2^((x - 1)/(sd_scale)))
})
# variance by order plots
focal_sd_scale <- unique(params$sd_scale)[c(F, T, F, F, T, F, F, T, F, F, T, F)]
rel_var <- do.call(rbind,
lapply(focal_sd_scale,
FUN = function(x) {
data.frame(sd_scale = x,
coeff_order = 1:N,
rel_var = scale_coeffs(1:N, sd_scale = x)^2 / sum(scale_coeffs(1:N, sd_scale = x)^2))
}))
View(rel_var)
scale_coeffs <- function(coeff_order, mean_scale = 1, sd_scale = 2) sapply(coeff_order,
FUN = function(x) {
if (x <= 1) return(1)
else return(0.2 + (1 - 0.2)*2^(-1*(x - 1)/(sd_scale)))
})
# variance by order plots
focal_sd_scale <- unique(params$sd_scale)[c(F, T, F, F, T, F, F, T, F, F, T, F)]
rel_var <- do.call(rbind,
lapply(focal_sd_scale,
FUN = function(x) {
data.frame(sd_scale = x,
coeff_order = 1:N,
rel_var = scale_coeffs(1:N, sd_scale = x)^2 / sum(scale_coeffs(1:N, sd_scale = x)^2))
}))
# params <- data.frame(mean_coeff = rep(seq(-1, 1, length.out = 7), 7),
#                      sd_coeff = rep(seq(0.1, 0.9, length.out = 7), each = 7))
# params <- do.call(rbind,
#                   lapply(10^seq(log10(0.4), log10(15), length.out = 12),
#                          FUN = function(x) cbind(params, sd_scale = x)))
# params <- do.call(rbind, replicate(8, params, simplify = FALSE))
params <- data.frame(mean_coeff = rep(seq(-1, 1, length.out = 4), 4),
sd_coeff = rep(seq(0.1, 0.9, length.out = 4), each = 4))
params <- do.call(rbind,
lapply(10^seq(log10(0.4), log10(15), length.out = 4),
FUN = function(x) cbind(params, sd_scale = x)))
params <- do.call(rbind, replicate(4, params, simplify = FALSE))
View(params)
# variance by order plots
focal_sd_scale <- unique(params$sd_scale)[c(F, T, F, F, T, F, F, T, F, F, T, F)]
rel_var <- do.call(rbind,
lapply(focal_sd_scale,
FUN = function(x) {
data.frame(sd_scale = x,
coeff_order = 1:N,
rel_var = scale_coeffs(1:N, sd_scale = x)^2 / sum(scale_coeffs(1:N, sd_scale = x)^2))
}))
ggplot(rel_var, aes(x = coeff_order, y = 100*rel_var, fill = coeff_order)) +
geom_bar(stat = 'identity') +
facet_wrap(~ sd_scale,
nrow = 1,
scales = 'free') +
scale_fill_gradient(name = '',
low = '#d32f37',
high = '#76d3d6',
limits = c(0, N),
breaks = pretty_breaks(n = 3)) +
scale_x_continuous(name = 'Order of interaction',
limits = c(0.5, N + 0.5)) +
scale_y_continuous(name = '% of functional\nvariance explained',
breaks = c(0, 50, 100),
limits = c(0, 100)) +
theme_bw() +
theme(aspect.ratio = 1,
panel.grid = element_blank(),
axis.title = element_text(size = 12),
axis.text = element_text(size = 12),
axis.ticks = element_blank(),
strip.background = element_blank(),
strip.text = element_blank(),
legend.text = element_text(size = 12),
legend.title = element_text(size = 12),
panel.spacing = unit(1, "lines"),
legend.position = 'none',
panel.border = element_blank()) +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, linewidth=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf, linewidth=0.5)
# variance by order plots
focal_sd_scale <- unique(params$sd_scale) #[c(F, T, F, F, T, F, F, T, F, F, T, F)]
rel_var <- do.call(rbind,
lapply(focal_sd_scale,
FUN = function(x) {
data.frame(sd_scale = x,
coeff_order = 1:N,
rel_var = scale_coeffs(1:N, sd_scale = x)^2 / sum(scale_coeffs(1:N, sd_scale = x)^2))
}))
ggplot(rel_var, aes(x = coeff_order, y = 100*rel_var, fill = coeff_order)) +
geom_bar(stat = 'identity') +
facet_wrap(~ sd_scale,
nrow = 1,
scales = 'free') +
scale_fill_gradient(name = '',
low = '#d32f37',
high = '#76d3d6',
limits = c(0, N),
breaks = pretty_breaks(n = 3)) +
scale_x_continuous(name = 'Order of interaction',
limits = c(0.5, N + 0.5)) +
scale_y_continuous(name = '% of functional\nvariance explained',
breaks = c(0, 50, 100),
limits = c(0, 100)) +
theme_bw() +
theme(aspect.ratio = 1,
panel.grid = element_blank(),
axis.title = element_text(size = 12),
axis.text = element_text(size = 12),
axis.ticks = element_blank(),
strip.background = element_blank(),
strip.text = element_blank(),
legend.text = element_text(size = 12),
legend.title = element_text(size = 12),
panel.spacing = unit(1, "lines"),
legend.position = 'none',
panel.border = element_blank()) +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, linewidth=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf, linewidth=0.5)
View(scale_coeffs)
rm(list = ls())
source('./ecoFunctions.R')
source('auxFunctions.R')
# load data
files <- c(list.files('../data_sets', full.names = T),
'../pyoverdine_data/training_set.csv', '../pyoverdine_data/test_set.csv')
data <- lapply(1:length(files),
FUN = function(i) {
df <- read.csv(files[i], header = T)
if (i == 3) df$function. <- df$function. / 1e4
if (i %in% c(6, 7)) df <- cbind(df[, 1:8],
function. = rowMeans(df[, 9:ncol(df)]))
df <- aggregate(function. ~ .,
data = df,
FUN = mean)
return(df)
})
data[[6]] <- rbind(data[[6]], data[[7]])
data <- data[1:6]
# wrapper function: fit self-consistent model
getSCfits <- function(df) {
params0 <- c(rep(0, ncol(df) - 1), 1)
gedf <- makeGEdata(matrix2string(df))
# error function to minimize
getSqErrors <- function(params) {
names(params) <- c(unique(gedf$knock_in), 'r')
model_df <- params[gedf$knock_in]*params['r'] + params[gedf$knock_in]*gedf$background_f
absolute_error <- model_df - gedf$d_f
sum_squared_error <- sum(absolute_error^2)
return(sum_squared_error)
}
# minimize error function
params_opt <- optim(params0, getSqErrors)
# return fit parameters
return(data.frame(knock_in = unique(gedf$knock_in),
slope = params_opt$par[1:(length(params_opt$par) - 1)],
intercept = params_opt$par[1:(length(params_opt$par) - 1)] * params_opt$par[length(params_opt$par)]))
}
# wrapper function: get predictions from self-consistent model via leave-one-out cross-validation
predictF_sc <- function(target_community, scfits, F0 = 0) {
target_sp <- strsplit(target_community, split = ',')[[1]]
f_target <- F0
for (sp in target_sp) f_target <- f_target +
scfits$intercept[scfits$knock_in == sp] +
scfits$slope[scfits$knock_in == sp]*f_target
return(f_target)
}
# get predictions vs observations
focal_dataset <- 6
df <- data[[focal_dataset]]
gedf <- makeGEdata(matrix2string(df))
scfits <- getSCfits(df)
po <- do.call(rbind,
lapply(2:nrow(df),
FUN = function(i) {
target_community <- orderName(paste(colnames(df[, 1:(ncol(df) - 1)])[df[i, 1:(ncol(df) - 1)] == 1],
collapse = ','))
df_outofsample <- df[i, ]
df_insample <- df[-i, ]
scfits <- getSCfits(df_insample)
fun_predicted <- predictF_sc(target_community, scfits)
return(data.frame(community = target_community,
fun_true = df_outofsample$function.,
fun_predicted = fun_predicted))
}))
mylm <- lm(fun_true ~ fun_predicted, data = po)
ggplot(gedf,
aes(x = background_f, y = d_f)) +
geom_abline(slope = 0, intercept = 0, color = 'gray') +
geom_point() +
geom_abline(data = scfits,
aes(slope = slope, intercept = intercept, color = slope)) +
scale_color_gradient2(low = 'firebrick1',
high = 'deepskyblue',
mid = 'black') +
scale_x_continuous(name = 'Background function [a.u.]',
breaks = pretty_breaks(n = 3)) +
scale_y_continuous(name = expression(paste(Delta*italic(F), ' [a.u.]')),
breaks = pretty_breaks(n = 2)) +
facet_wrap(~ knock_in,
nrow = 2) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(size = 14),
panel.border = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
ggplot(gedf,
aes(x = background_f, y = d_f)) +
geom_abline(slope = 0, intercept = 0, color = 'gray') +
geom_point() +
geom_abline(data = scfits,
aes(slope = slope, intercept = intercept, color = slope)) +
scale_color_gradient2(low = 'firebrick1',
high = 'deepskyblue',
mid = 'black') +
scale_x_continuous(name = 'Background function [a.u.]',
breaks = pretty_breaks(n = 3)) +
scale_y_continuous(name = expression(paste(Delta*italic(F), ' [a.u.]')),
breaks = pretty_breaks(n = 2)) +
facet_wrap(~ knock_in,
nrow = 2) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(size = 14),
panel.border = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
ggsave(filename = '../plots/self_consistent_models/scFEEs.pdf',
device = 'pdf',
dpi = 600,
width = 100,
height = 75,
units = 'mm',
limitsize = F)
ggsave(filename = '../plots/self_consistent_models/scFEEs.pdf',
device = 'pdf',
dpi = 600,
width = 125,
height = 75,
units = 'mm',
limitsize = F)
View(scfits)
scfits$slope*scfits$intercept
scfits$slope/scfits$intercept
View(df)
fees <- makeFEEs(makeGEdata(matrix2string(df)))
View(fees)
# wrapper function: fit self-consistent model
getSCfits <- function(df) {
fees <- makeFEEs(makeGEdata(matrix2string(df)))
params0 <- c(fees$b, mean(fees$a/fees$b, na.rm = T))
gedf <- makeGEdata(matrix2string(df))
# error function to minimize
getSqErrors <- function(params) {
names(params) <- c(unique(gedf$knock_in), 'r')
model_df <- params[gedf$knock_in]*params['r'] + params[gedf$knock_in]*gedf$background_f
absolute_error <- model_df - gedf$d_f
sum_squared_error <- sum(absolute_error^2)
return(sum_squared_error)
}
# minimize error function
params_opt <- optim(params0, getSqErrors)
# return fit parameters
return(data.frame(knock_in = unique(gedf$knock_in),
slope = params_opt$par[1:(length(params_opt$par) - 1)],
intercept = params_opt$par[1:(length(params_opt$par) - 1)] * params_opt$par[length(params_opt$par)]))
}
# get self-consistent FEEs
focal_dataset <- 6
df <- data[[focal_dataset]]
gedf <- makeGEdata(matrix2string(df))
scfits <- getSCfits(df)
ggplot(gedf,
aes(x = background_f, y = d_f)) +
geom_abline(slope = 0, intercept = 0, color = 'gray') +
geom_point() +
geom_abline(data = scfits,
aes(slope = slope, intercept = intercept, color = slope)) +
scale_color_gradient2(low = 'firebrick1',
high = 'deepskyblue',
mid = 'black') +
scale_x_continuous(name = 'Background function [a.u.]',
breaks = pretty_breaks(n = 3)) +
scale_y_continuous(name = expression(paste(Delta*italic(F), ' [a.u.]')),
breaks = pretty_breaks(n = 2)) +
facet_wrap(~ knock_in,
nrow = 2) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(size = 14),
panel.border = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
scfits
scfits$slope/scfits$intercept
# get predictions vs observations
po <- do.call(rbind,
lapply(2:nrow(df),
FUN = function(i) {
target_community <- orderName(paste(colnames(df[, 1:(ncol(df) - 1)])[df[i, 1:(ncol(df) - 1)] == 1],
collapse = ','))
df_outofsample <- df[i, ]
df_insample <- df[-i, ]
scfits <- getSCfits(df_insample)
fun_predicted <- predictF_sc(target_community, scfits)
return(data.frame(community = target_community,
fun_true = df_outofsample$function.,
fun_predicted = fun_predicted))
}))
mylm <- lm(fun_true ~ fun_predicted, data = po)
ggplot(gedf,
aes(x = background_f, y = d_f)) +
geom_abline(slope = 0, intercept = 0, color = 'gray') +
geom_point() +
geom_abline(data = scfits,
aes(slope = slope, intercept = intercept, color = slope)) +
scale_color_gradient2(low = 'firebrick1',
high = 'deepskyblue',
mid = 'black') +
scale_x_continuous(name = 'Background function [a.u.]',
breaks = pretty_breaks(n = 3)) +
scale_y_continuous(name = expression(paste(Delta*italic(F), ' [a.u.]')),
breaks = pretty_breaks(n = 2)) +
facet_wrap(~ knock_in,
nrow = 2) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(size = 14),
panel.border = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
ggsave(filename = '../plots/self_consistent_models/scFEEs.pdf',
device = 'pdf',
dpi = 600,
width = 125,
height = 75,
units = 'mm',
limitsize = F)
# predicted vs observed
ggplot(po, aes(x = fun_predicted, y = fun_true)) +
geom_blank(aes(x = fun_true, y = fun_predicted)) +
geom_abline(slope = 1,
intercept = 0,
color = 'gray') +
geom_point() +
scale_x_continuous(name = expression(paste(Predicted~italic(F), ' [a.u.]')),
breaks = pretty_breaks(n = 4)) +
scale_y_continuous(name = expression(paste(Empirical~italic(F), ' [a.u.]')),
breaks = pretty_breaks(n = 4)) +
theme_bw() +
theme(aspect.ratio = 1,
panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(size = 14),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.position = 'none')
ggsave(filename = '../plots/self_consistent_models/po_sc_pyoverdine.pdf',
device = 'pdf',
dpi = 600,
width = 75,
height = 75,
units = 'mm',
limitsize = F)
ggsave(filename = '../plots/self_consistent_models/po_sc_pyoverdine.pdf',
device = 'pdf',
dpi = 600,
width = 75,
height = 75,
units = 'mm',
limitsize = F)
summary(mylm)
R2_identity <- 1 - sum((po$fun_true - po$fun_predicted)^2)/sum((po$fun_true - mean(po$fun_true))^2)
cor(po$fun_true, po$fun_predicted, method = 'Spearman')
cor(po$fun_true, po$fun_predicted, method = 'spearman')

source('./auxFunctions.R')
N <- 8 # number of species
comms <- makeComms(N)
# tune weight of higher-order interactions
scale_coeffs <- function(coeff_order, mean_scale = 1, sd_scale = 2) exp(-(coeff_order - mean_scale)^2/sd_scale^2)
# interaction coefficients plots (wrapper function)
makeCoeffPlots <- function(sd_scale = 2) {
mean_coeff <- rep(c(-1, 0, 1), 3)
sd_coeff <- rep(c(0.1, 0.5, 0.9), each = 3)
n_points <- 10000
plot_this_all <- data.frame(case = character(0),
order = numeric(0),
y = numeric(0))
for (i in 1:length(mean_coeff)) {
plot_this <- data.frame(order = rep(1:N, each = n_points),
y = rnorm(n_points*N, mean = mean_coeff[i], sd = sd_coeff[i]))
plot_this$y <- plot_this$y * scale_coeffs(plot_this$order, sd_scale = sd_scale)
plot_this_all <- rbind(plot_this_all,
cbind(case = LETTERS[i],
plot_this))
}
ylim <- 3
plot_this_all <- plot_this_all[abs(plot_this_all$y) < ylim, ]
myplot <-
ggplot(plot_this_all,
aes(x = order, y = y, group = order, fill = order)) +
geom_abline(slope = 0,
intercept = 0,
color = 'gray',
linewidth = 0.5) +
geom_violin(scale = 'width',
width = 0.5,
#fill = 'gray',
color = NA) +
scale_y_continuous(name = expression(paste('Interaction coefficient, ', italic(delta), sep = '')),
limits = c(-ylim, ylim),
breaks = c(-1.5, 0, 1.5)) +
scale_x_continuous(name = 'Order of interaction',
breaks = 1:N,
limits = c(1-0.5, N+0.5)) +
facet_wrap(~case) +
scale_fill_gradient(low = '#76d3d6', high = '#d32f37') +
theme_bw() + theme(aspect.ratio = 0.4,
panel.grid = element_blank(),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
panel.border = element_blank(),
legend.position = 'none',
strip.background = element_blank(),
strip.text = element_blank()) +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
return(myplot)
}
params <- data.frame(mean_coeff = rep(seq(-1, 1, length.out = 3), 3),
sd_coeff = rep(seq(0.1, 0.9, length.out = 3), each = 3))
params <- do.call(rbind,
lapply(10^seq(log10(0.4), log10(15), length.out = 5),
FUN = function(x) cbind(params, sd_scale = x)))
params <- do.call(rbind, replicate(5, params, simplify = FALSE))
params <- cbind(params,
rs = NA,
R2_stitching = NA,
R2.identity_stitching = NA,
relError.mean_topbot10_stitching = NA,
relError.sd_topbot10_stitching = NA,
R2_topbot10_stitching = NA,
R2.identity_topbot10_stitching = NA,
R2_reg1 = NA,
R2.identity_reg1 = NA,
relError.mean_topbot10_reg1 = NA,
relError.sd_topbot10_reg1 = NA,
R2_topbot10_reg1 = NA,
R2.identity_topbot10_reg1 = NA,
R2_reg2 = NA,
R2.identity_reg2 = NA,
relError.mean_topbot10_reg2 = NA,
relError.sd_topbot10_reg2 = NA,
R2_topbot10_reg2 = NA,
R2.identity_topbot10_reg2 = NA)
write.table(as.data.frame(t(colnames(params))),
file = './syntheticLandscapes_params_multi.txt',
quote = F,
row.names = F,
col.names = F,
sep = '\t')
for (p in 1:nrow(params)) {
print(paste('Synth. landscape ', p, ' of ', nrow(params), ' (', round(100*p/nrow(params)), '%)', sep = ''))
# sample Fourier coefficients
coeff <- setNames(unlist(lapply(0:N,
FUN = function(i) apply(t(combn(N, i)),
FUN = function(x) rnorm(1,
mean = params$mean_coeff[p],
sd = params$sd_coeff[p]),
MARGIN = 1))),
unlist(lapply(0:N,
FUN = function(i) apply(t(combn(N, i)),
FUN = function(x) paste(x, collapse = ''),
MARGIN = 1))))
coeff <- coeff * scale_coeffs(nchar(names(coeff)), sd_scale = params$sd_scale[p])
# make synthetic landscape
synthLandscape <- cbind(comms,
fun = funFromCoeff(comms, coeff))
#plotFitnessGraph(synthLandscape)
#plotFEEs_clean(synthLandscape)
# get ruggedness
params$rs[p] <- get_rs(synthLandscape)
# evaluate quality of predictions (stitching method) in synthetic landscape
po <- evaluatePredictions_mult(synthLandscape)
mylm <- lm(fun_true ~ fun_predicted, data = po)
#po_extremes <- po[po$fun_true > quantile(po$fun_true, probs = 0.9) | po$fun_true < quantile(po$fun_true, probs = 0.1), ]
#mylm_ext <- lm(fun_true ~ fun_predicted, data = po_extremes)
params$R2_stitching[p] <- summary(mylm)$r.squared
params$R2.identity_stitching[p] <- 1 - sum((po$fun_true - po$fun_predicted)^2)/sum((po$fun_true - mean(po$fun_true))^2)
#params$relError.mean_topbot10_stitching[p] <- mean(abs((po_extremes$fun_predicted - po_extremes$fun_true) / po_extremes$fun_true))
#params$relError.sd_topbot10_stitching[p] <- sd(abs((po_extremes$fun_predicted - po_extremes$fun_true) / po_extremes$fun_true))
#params$R2_topbot10_stitching[p] = summary(mylm_ext)$r.squared
#params$R2.identity_topbot10_stitching[p] = 1 - sum((po_extremes$fun_true - po_extremes$fun_predicted)^2)/sum((po_extremes$fun_true - mean(po_extremes$fun_true))^2)
# evaluate quality of predictions by 1st and 2nd order regressions
po <- get_all_loo_fits_mult(synthLandscape)
# 1st order
mylm <- lm(fun_true ~ fun_pred_1st, data = po)
#po_extremes <- po[po$fun_true > quantile(po$fun_true, probs = 0.9) | po$fun_true < quantile(po$fun_true, probs = 0.1), ]
#mylm_ext <- lm(fun_true ~ fun_pred_1st, data = po_extremes)
params$R2_reg1[p] <- summary(mylm)$r.squared
params$R2.identity_reg1[p] <- 1 - sum((po$fun_true - po$fun_pred_1st)^2)/sum((po$fun_true - mean(po$fun_true))^2)
#params$relError.mean_topbot10_reg1[p] <- mean(abs((po_extremes$fun_pred_1st - po_extremes$fun_true) / po_extremes$fun_true))
#params$relError.sd_topbot10_reg1[p] <- sd(abs((po_extremes$fun_pred_1st - po_extremes$fun_true) / po_extremes$fun_true))
#params$R2_topbot10_reg1[p] = summary(mylm_ext)$r.squared
#params$R2.identity_topbot10_reg1[p] = 1 - sum((po_extremes$fun_true - po_extremes$fun_pred_1st)^2)/sum((po_extremes$fun_true - mean(po_extremes$fun_true))^2)
# 2nd order
mylm <- lm(fun_true ~ fun_pred_2nd, data = po)
#po_extremes <- po[po$fun_true > quantile(po$fun_true, probs = 0.9) | po$fun_true < quantile(po$fun_true, probs = 0.1), ]
#mylm_ext <- lm(fun_true ~ fun_pred_2nd, data = po_extremes)
params$R2_reg2[p] <- summary(mylm)$r.squared
params$R2.identity_reg2[p] <- 1 - sum((po$fun_true - po$fun_pred_2nd)^2)/sum((po$fun_true - mean(po$fun_true))^2)
#params$relError.mean_topbot10_reg2[p] <- mean(abs((po_extremes$fun_pred_2nd - po_extremes$fun_true) / po_extremes$fun_true))
#params$relError.sd_topbot10_reg2[p] <- sd(abs((po_extremes$fun_pred_2nd - po_extremes$fun_true) / po_extremes$fun_true))
#params$R2_topbot10_reg2[p] = summary(mylm_ext)$r.squared
#params$R2.identity_topbot10_reg2[p] = 1 - sum((po_extremes$fun_true - po_extremes$fun_pred_2nd)^2)/sum((po_extremes$fun_true - mean(po_extremes$fun_true))^2)
# save
write.table(params[p, , drop = F],
file = './syntheticLandscapes_params_multi.txt',
quote = F,
row.names = F,
col.names = F,
sep = '\t',
append = T)
}
warnings()
mycolors <- c('#99d7dc', '#176766', '#b33a3b')
tst <- aggregate(R2.identity_stitching ~ mean_coeff + sd_coeff + sd_scale,
data = params,
FUN = mean)
ggplot(tst,
aes(x = mean_coeff, y = sd_coeff, fill = pmax(R2.identity_stitching, 0))) +
geom_tile() +
scale_y_continuous(name = expression(sd~(italic(epsilon)[italic(ij)])),
expand = c(0, 0),
breaks = c(0.1, 0.5, 0.9)) +
scale_x_continuous(name = expression(mean~(italic(epsilon)[italic(ij)])),
expand = c(0, 0),
breaks = c(-1, 0, 1)) +
scale_fill_gradient2(low = '#d32f37',
high = '#76d3d6',
limits = c(0, 1),
midpoint = 0.5,
breaks = pretty_breaks(n = 3)) +
facet_wrap(~ sd_scale, nrow = 1) +
theme_bw() +
theme(aspect.ratio = 1,
panel.grid = element_blank(),
axis.title = element_text(size = 16),
axis.text = element_text(size = 16),
axis.ticks = element_blank()) +
guides(fill=guide_colorbar(ticks.colour = NA))
tst <- gather(params[, c('rs',
'R2.identity_stitching',
'R2.identity_reg1',
'R2.identity_reg2')],
prediction_method, R2, 2:4, factor_key = FALSE)
# tst <- gather(params[, c('rs',
#                        'R2.identity_stitching',
#                        'R2.identity_reg1',
#                        'R2.identity_reg2')],
#               prediction_method, R2, 2:4, factor_key = FALSE)
tst$R2 <- pmax(0, tst$R2)
tst$rs <- log10(tst$rs)
tst$prediction_method <- setNames(c('1st order regression',
'2nd order regression',
'FEE concatenation'),
unique(tst$prediction_method)[c(which(grepl('reg1', unique(tst$prediction_method))),
which(grepl('reg2', unique(tst$prediction_method))),
which(grepl('stitching', unique(tst$prediction_method))))])[tst$prediction_method]
tst$prediction_method <- factor(tst$prediction_method,
levels = c('1st order regression',
'2nd order regression',
'FEE concatenation'))
# fit logistic functions
mylns <- do.call(rbind,
lapply(unique(tst$prediction_method),
FUN = function(method) {
lns_i <- nls(R2 ~ myLogistic(rs, A, B),
tst[tst$prediction_method == method, ],
start = list(A = 1, B = 0))
return(cbind(prediction_method = method,
as.data.frame(t(coef(lns_i)))))
}))
ggplot(tst[tst$rs > -1 & tst$rs < 1, ],
aes(x = rs, y = R2, color = prediction_method)) +
geom_point(alpha = 0.25) +
geom_function(fun = myLogistic, args = list(A = mylns$A[2], B = mylns$B[2]),
color = mycolors[1],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[3], B = mylns$B[3]),
color = mycolors[2],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[1], B = mylns$B[1]),
color = mycolors[3],
linewidth = 1) +
scale_x_continuous(name = 'Ruggedness (r/s)',
breaks = c(-1, 0, 1),
labels = c(expression(10^-1), expression(10^0), expression(10^1))) +
scale_y_continuous(name = expression(paste(italic(R)^2, ' predictions vs. observations,')),
breaks = c(0, 0.5, 1)) +
scale_color_manual(values = mycolors) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
axis.ticks = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16))
rm(list = ls())
source('./ecoFunctions.R')
source('./auxFunctions.R')
N <- 8 # number of species
comms <- makeComms(N)
# tune weight of higher-order interactions
scale_coeffs <- function(coeff_order, mean_scale = 1, sd_scale = 2) exp(-(coeff_order - mean_scale)^2/sd_scale^2)
# interaction coefficients plots (wrapper function)
makeCoeffPlots <- function(sd_scale = 2) {
mean_coeff <- rep(c(-1, 0, 1), 3)
sd_coeff <- rep(c(0.1, 0.5, 0.9), each = 3)
n_points <- 10000
plot_this_all <- data.frame(case = character(0),
order = numeric(0),
y = numeric(0))
for (i in 1:length(mean_coeff)) {
plot_this <- data.frame(order = rep(1:N, each = n_points),
y = rnorm(n_points*N, mean = mean_coeff[i], sd = sd_coeff[i]))
plot_this$y <- plot_this$y * scale_coeffs(plot_this$order, sd_scale = sd_scale)
plot_this_all <- rbind(plot_this_all,
cbind(case = LETTERS[i],
plot_this))
}
ylim <- 3
plot_this_all <- plot_this_all[abs(plot_this_all$y) < ylim, ]
myplot <-
ggplot(plot_this_all,
aes(x = order, y = y, group = order, fill = order)) +
geom_abline(slope = 0,
intercept = 0,
color = 'gray',
linewidth = 0.5) +
geom_violin(scale = 'width',
width = 0.5,
#fill = 'gray',
color = NA) +
scale_y_continuous(name = expression(paste('Interaction coefficient, ', italic(delta), sep = '')),
limits = c(-ylim, ylim),
breaks = c(-1.5, 0, 1.5)) +
scale_x_continuous(name = 'Order of interaction',
breaks = 1:N,
limits = c(1-0.5, N+0.5)) +
facet_wrap(~case) +
scale_fill_gradient(low = '#76d3d6', high = '#d32f37') +
theme_bw() + theme(aspect.ratio = 0.4,
panel.grid = element_blank(),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
panel.border = element_blank(),
legend.position = 'none',
strip.background = element_blank(),
strip.text = element_blank()) +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
return(myplot)
}
# params <- data.frame(mean_coeff = rep(seq(-1, 1, length.out = 7), 7),
#                      sd_coeff = rep(seq(0.1, 0.9, length.out = 7), each = 7))
# params <- do.call(rbind,
#                   lapply(10^seq(log10(0.4), log10(15), length.out = 10),
#                          FUN = function(x) cbind(params, sd_scale = x)))
# params <- do.call(rbind, replicate(10, params, simplify = FALSE))
params <- data.frame(mean_coeff = rep(seq(-1, 1, length.out = 3), 3),
sd_coeff = rep(seq(0.1, 0.9, length.out = 3), each = 3))
params <- do.call(rbind,
lapply(10^seq(log10(0.4), log10(15), length.out = 5),
FUN = function(x) cbind(params, sd_scale = x)))
params <- do.call(rbind, replicate(5, params, simplify = FALSE))
params <- cbind(params,
rs = NA,
R2_stitching = NA,
R2.identity_stitching = NA,
relError.mean_topbot10_stitching = NA,
relError.sd_topbot10_stitching = NA,
R2_topbot10_stitching = NA,
R2.identity_topbot10_stitching = NA,
R2_reg1 = NA,
R2.identity_reg1 = NA,
relError.mean_topbot10_reg1 = NA,
relError.sd_topbot10_reg1 = NA,
R2_topbot10_reg1 = NA,
R2.identity_topbot10_reg1 = NA,
R2_reg2 = NA,
R2.identity_reg2 = NA,
relError.mean_topbot10_reg2 = NA,
relError.sd_topbot10_reg2 = NA,
R2_topbot10_reg2 = NA,
R2.identity_topbot10_reg2 = NA)
write.table(as.data.frame(t(colnames(params))),
file = './syntheticLandscapes_params.txt',
quote = F,
row.names = F,
col.names = F,
sep = '\t')
for (p in 1:nrow(params)) {
print(paste('Synth. landscape ', p, ' of ', nrow(params), ' (', round(100*p/nrow(params)), '%)', sep = ''))
# sample Fourier coefficients
coeff <- setNames(unlist(lapply(0:N,
FUN = function(i) apply(t(combn(N, i)),
FUN = function(x) rnorm(1,
mean = params$mean_coeff[p],
sd = params$sd_coeff[p]),
MARGIN = 1))),
unlist(lapply(0:N,
FUN = function(i) apply(t(combn(N, i)),
FUN = function(x) paste(x, collapse = ''),
MARGIN = 1))))
coeff <- coeff * scale_coeffs(nchar(names(coeff)), sd_scale = params$sd_scale[p])
# make synthetic landscape
synthLandscape <- cbind(comms,
fun = funFromCoeff(comms, coeff))
#plotFitnessGraph(synthLandscape)
#plotFEEs_clean(synthLandscape)
# get ruggedness
params$rs[p] <- get_rs(synthLandscape)
# evaluate quality of predictions (stitching method) in synthetic landscape
po <- evaluatePredictions(synthLandscape)
mylm <- lm(fun_true ~ fun_predicted, data = po)
po_extremes <- po[po$fun_true > quantile(po$fun_true, probs = 0.9) | po$fun_true < quantile(po$fun_true, probs = 0.1), ]
mylm_ext <- lm(fun_true ~ fun_predicted, data = po_extremes)
params$R2_stitching[p] <- summary(mylm)$r.squared
params$R2.identity_stitching[p] <- 1 - sum((po$fun_true - po$fun_predicted)^2)/sum((po$fun_true - mean(po$fun_true))^2)
params$relError.mean_topbot10_stitching[p] <- mean(abs((po_extremes$fun_predicted - po_extremes$fun_true) / po_extremes$fun_true))
params$relError.sd_topbot10_stitching[p] <- sd(abs((po_extremes$fun_predicted - po_extremes$fun_true) / po_extremes$fun_true))
params$R2_topbot10_stitching[p] = summary(mylm_ext)$r.squared
params$R2.identity_topbot10_stitching[p] = 1 - sum((po_extremes$fun_true - po_extremes$fun_predicted)^2)/sum((po_extremes$fun_true - mean(po_extremes$fun_true))^2)
# evaluate quality of predictions by 1st and 2nd order regressions
po <- get_all_loo_fits(synthLandscape)
# 1st order
mylm <- lm(fun_true ~ fun_pred_1st, data = po)
po_extremes <- po[po$fun_true > quantile(po$fun_true, probs = 0.9) | po$fun_true < quantile(po$fun_true, probs = 0.1), ]
mylm_ext <- lm(fun_true ~ fun_pred_1st, data = po_extremes)
params$R2_reg1[p] <- summary(mylm)$r.squared
params$R2.identity_reg1[p] <- 1 - sum((po$fun_true - po$fun_pred_1st)^2)/sum((po$fun_true - mean(po$fun_true))^2)
params$relError.mean_topbot10_reg1[p] <- mean(abs((po_extremes$fun_pred_1st - po_extremes$fun_true) / po_extremes$fun_true))
params$relError.sd_topbot10_reg1[p] <- sd(abs((po_extremes$fun_pred_1st - po_extremes$fun_true) / po_extremes$fun_true))
params$R2_topbot10_reg1[p] = summary(mylm_ext)$r.squared
params$R2.identity_topbot10_reg1[p] = 1 - sum((po_extremes$fun_true - po_extremes$fun_pred_1st)^2)/sum((po_extremes$fun_true - mean(po_extremes$fun_true))^2)
# 2nd order
mylm <- lm(fun_true ~ fun_pred_2nd, data = po)
po_extremes <- po[po$fun_true > quantile(po$fun_true, probs = 0.9) | po$fun_true < quantile(po$fun_true, probs = 0.1), ]
mylm_ext <- lm(fun_true ~ fun_pred_2nd, data = po_extremes)
params$R2_reg2[p] <- summary(mylm)$r.squared
params$R2.identity_reg2[p] <- 1 - sum((po$fun_true - po$fun_pred_2nd)^2)/sum((po$fun_true - mean(po$fun_true))^2)
params$relError.mean_topbot10_reg2[p] <- mean(abs((po_extremes$fun_pred_2nd - po_extremes$fun_true) / po_extremes$fun_true))
params$relError.sd_topbot10_reg2[p] <- sd(abs((po_extremes$fun_pred_2nd - po_extremes$fun_true) / po_extremes$fun_true))
params$R2_topbot10_reg2[p] = summary(mylm_ext)$r.squared
params$R2.identity_topbot10_reg2[p] = 1 - sum((po_extremes$fun_true - po_extremes$fun_pred_2nd)^2)/sum((po_extremes$fun_true - mean(po_extremes$fun_true))^2)
# save
write.table(params[p, , drop = F],
file = './syntheticLandscapes_params.txt',
quote = F,
row.names = F,
col.names = F,
sep = '\t',
append = T)
}
rm(list = ls())
source('./ecoFunctions.R')
source('./auxFunctions.R')
N <- 8 # number of species
comms <- makeComms(N)
# tune weight of higher-order interactions
scale_coeffs <- function(coeff_order, mean_scale = 1, sd_scale = 2) exp(-(coeff_order - mean_scale)^2/sd_scale^2)
# interaction coefficients plots (wrapper function)
makeCoeffPlots <- function(sd_scale = 2) {
mean_coeff <- rep(c(-1, 0, 1), 3)
sd_coeff <- rep(c(0.1, 0.5, 0.9), each = 3)
n_points <- 10000
plot_this_all <- data.frame(case = character(0),
order = numeric(0),
y = numeric(0))
for (i in 1:length(mean_coeff)) {
plot_this <- data.frame(order = rep(1:N, each = n_points),
y = rnorm(n_points*N, mean = mean_coeff[i], sd = sd_coeff[i]))
plot_this$y <- plot_this$y * scale_coeffs(plot_this$order, sd_scale = sd_scale)
plot_this_all <- rbind(plot_this_all,
cbind(case = LETTERS[i],
plot_this))
}
ylim <- 3
plot_this_all <- plot_this_all[abs(plot_this_all$y) < ylim, ]
myplot <-
ggplot(plot_this_all,
aes(x = order, y = y, group = order, fill = order)) +
geom_abline(slope = 0,
intercept = 0,
color = 'gray',
linewidth = 0.5) +
geom_violin(scale = 'width',
width = 0.5,
#fill = 'gray',
color = NA) +
scale_y_continuous(name = expression(paste('Interaction coefficient, ', italic(delta), sep = '')),
limits = c(-ylim, ylim),
breaks = c(-1.5, 0, 1.5)) +
scale_x_continuous(name = 'Order of interaction',
breaks = 1:N,
limits = c(1-0.5, N+0.5)) +
facet_wrap(~case) +
scale_fill_gradient(low = '#76d3d6', high = '#d32f37') +
theme_bw() + theme(aspect.ratio = 0.4,
panel.grid = element_blank(),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
panel.border = element_blank(),
legend.position = 'none',
strip.background = element_blank(),
strip.text = element_blank()) +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
return(myplot)
}
params <- data.frame(mean_coeff = rep(seq(-1, 1, length.out = 7), 7),
sd_coeff = rep(seq(0.1, 0.9, length.out = 7), each = 7))
params <- do.call(rbind,
lapply(10^seq(log10(0.4), log10(15), length.out = 10),
FUN = function(x) cbind(params, sd_scale = x)))
params <- do.call(rbind, replicate(10, params, simplify = FALSE))
params <- cbind(params,
rs = NA,
R2_stitching = NA,
R2.identity_stitching = NA,
relError.mean_topbot10_stitching = NA,
relError.sd_topbot10_stitching = NA,
R2_topbot10_stitching = NA,
R2.identity_topbot10_stitching = NA,
R2_reg1 = NA,
R2.identity_reg1 = NA,
relError.mean_topbot10_reg1 = NA,
relError.sd_topbot10_reg1 = NA,
R2_topbot10_reg1 = NA,
R2.identity_topbot10_reg1 = NA,
R2_reg2 = NA,
R2.identity_reg2 = NA,
relError.mean_topbot10_reg2 = NA,
relError.sd_topbot10_reg2 = NA,
R2_topbot10_reg2 = NA,
R2.identity_topbot10_reg2 = NA)
4900/225
4900/225 * 0.5
ggsave(filename = '../plots/synthLandscapes/R2_vs_ruggedness.pdf',
device = 'pdf',
dpi = 600,
width = 100,
height = 75,
units = 'mm',
limitsize = F)
ggsave(filename = '../plots/synthLandscapes/R2_vs_ruggedness.pdf',
device = 'pdf',
dpi = 600,
width = 150,
height = 125,
units = 'mm',
limitsize = F)
ggplot(tst[tst$rs > -1 & tst$rs < 1, ],
aes(x = rs, y = R2, color = prediction_method)) +
geom_point(alpha = 0.25) +
geom_function(fun = myLogistic, args = list(A = mylns$A[2], B = mylns$B[2]),
color = mycolors[1],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[3], B = mylns$B[3]),
color = mycolors[2],
linewidth = 1) +
geom_function(fun = myLogistic, args = list(A = mylns$A[1], B = mylns$B[1]),
color = mycolors[3],
linewidth = 1) +
scale_x_continuous(name = 'Ruggedness (r/s)',
breaks = c(-1, 0, 1),
labels = c(expression(10^-1), expression(10^0), expression(10^1))) +
scale_y_continuous(name = expression(paste(italic(R)^2, ' predictions vs. observations,')),
breaks = c(0, 0.5, 1)) +
scale_color_manual(values = mycolors) +
theme_bw() +
theme(aspect.ratio = 0.6,
panel.grid = element_blank(),
axis.ticks = element_blank(),
axis.text = element_text(size = 16),
axis.title = element_text(size = 16),
legend.text = element_text(size = 14))

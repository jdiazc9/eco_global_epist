# returns TRUE if species is present in community, FALSE otherwise
return(sapply(community,
FUN = function(comm) species %in% strsplit(comm, split = ',')[[1]]))
}
makeGEdata <- function(data) {
# takes a mapping between community structures and functions and returns a data frame of species functional effects
# input data must be a data frame where he first column corresponds to genotype names and the second column corresponds to genotype fitness
# genotype names should be such that present mutations appear separated by commas with no spaces, e.g. 'sp1,sp2,sp3,...'
# use matrix2string() function to convert data to this format if needed
# name columns of data
colnames(data) <- c('community', 'f')
# order community names alphabetically
data[, 1] <- orderName(data[, 1])
# if there are multiple instances of a same genotype, take the average and print a warning
if(!all(table(data[, 1]) == 1)) {
warning(paste('Multiple instances of a same combination in input data set:\n',
paste(names(table(data[, 1]))[table(data[, 1]) > 1], collapse = '\n'),
'\nAveraging F to proceed.', sep = ''))
data <- aggregate(formula = f ~ community,
data = data,
FUN = mean)
}
# extract species names
species <- sort(unique(unlist(strsplit(data[, 1], split = ','))))
n_species <- length(species)
# functions as named array
f <- setNames(data[, 2], data[, 1])
# output: data frame where the effect of each species on a background community is isolated
ge_data <- do.call(rbind,
lapply(species,
FUN = function(sp) {
# fetch all communities in sample that contain species sp
knockins <- data$community[containsSpecies(sp, data$community)]
# backgrounds corresponding to those communities
backgrounds <- as.character(sapply(knockins,
FUN = function(x) {
x <- strsplit(x, split = ',')[[1]]
x <- x[x != sp]
x <- paste(x, collapse = ',')
return(x)
}))
# functions of backrounds and backgrounds + knock-ins
f_knockins <- as.numeric(f[knockins])
f_backgrounds <- as.numeric(f[backgrounds])
# build data frame
df <- data.frame(background = backgrounds,
knock_in = sp,
background_f = f_backgrounds,
d_f = f_knockins - f_backgrounds)
# keep only rows where the function of both the background and the knockin are known
df <- df[!is.na(df$background_f) & !is.na(df$d_f), ]
rownames(df) <- NULL
return(df)
}))
return(ge_data)
}
plotFEEs <- function(ge_data) {
# make dF-vs-F plots
p <-
ggplot(ge_data, aes(x = background_f, y = d_f)) +
geom_abline(slope = 0,
intercept = 0,
color = '#d1d3d4') +
geom_point(shape = 1,
cex = 2) +
geom_smooth(method = 'lm',
formula = y~x,
color = 'firebrick1',
se = F,
fullrange = T) +
scale_x_continuous(breaks = pretty_breaks(n = 3),
name = 'Function of ecological background [a.u.]') +
scale_y_continuous(breaks = pretty_breaks(n = 3),
name = 'dF [a.u.]') +
facet_wrap(~knock_in) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(face = 'italic',
size = 10),
aspect.ratio = 0.6,
axis.text = element_text(size = 16),
axis.title = element_text(size = 18),
panel.border = element_blank(),
panel.background = element_blank(),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
print(p)
return(p)
}
closestPaths <- function(target_comm, comm_list) {
# given a focal community (comm) and a list of other communities (comm_list), returns those in comm_list that are closest to comm (in terms of species addition/removal)
all_comms <- data.frame(community = c(target_comm, comm_list),
fun = NA)
all_comms <- string2matrix(all_comms)
comm <- all_comms[1, 1:(ncol(all_comms) - 1)]
comm_list <- all_comms[2:nrow(all_comms), 1:(ncol(all_comms) - 1)]
dist <- sapply(1:nrow(comm_list),
FUN = function(i) sum(abs(comm_list[i, ] - comm)))
which_min <- which(dist == min(dist))
closest_comms <- comm_list[which_min, ]
# paths to comm
paths <- lapply(1:nrow(closest_comms),
FUN = function(i) comm - closest_comms[i, ])
paths <- do.call(rbind, paths)
sources <- matrix2string(cbind(as.data.frame(closest_comms), fun = NA))$community
# return info
return(cbind(source = sources, target = target_comm, dist = dist[which_min], as.data.frame(paths)))
}
### LOAD DATA FOR TESTING
data <- read.table('../pyoverdine_data/pyo_rep3.txt', header = T)
data <- rbind(data, data.frame(community = '', fun = 0))
ge_data <- makeGEdata(data)
fetchResiduals <- function(paths) {}
# fetch which residuals (epsilons) take part in a given path (from a source to a target community)
# accounts for every possible path order (e.g. i->j->k, j->i->k, k->i->j, ...)
# variable naming: eps_i(s) is named s+i (e.g. 'i,j+k', 'i,k+j', 'i,j,k+l', ...)
set.seed(0)
target_comm <- data$community[100]
data <- data[-100, ]
data <- data[sample(1:nrow(data), size = 100), ]
paths <- closestPaths(target_comm, data$community)
paths
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
target_comm
target_comm %in% data$community
paths <- closestPaths(target_comm, data$community)
data$community
comm_list <- data$community
all_comms <- data.frame(community = c(target_comm, comm_list),
fun = NA)
all_comms <- string2matrix(all_comms)
comm <- all_comms[1, 1:(ncol(all_comms) - 1)]
comm_list <- all_comms[2:nrow(all_comms), 1:(ncol(all_comms) - 1)]
View(all_comms)
dist <- sapply(1:nrow(comm_list),
FUN = function(i) sum(abs(comm_list[i, ] - comm)))
dist
which_min <- which(dist == min(dist))
closest_comms <- comm_list[which_min, ]
# paths to comm
paths <- lapply(1:nrow(closest_comms),
FUN = function(i) comm - closest_comms[i, ])
comm
1:nrow(closest_comms)
closest_comms <- as.matrix(comm_list[which_min, ])
View(closest_comms)
closest_comms <- comm_list[which_min, ]
closest_comms
closest_comms[1, ]
which_min
if (length(which_min) == 1) closest_comms <- matrix(closest_comms, nrow = 1)
View(closest_comms)
comm
if (length(which_min) == 1) {
closest_comms <- matrix(closest_comms, nrow = 1)
colnames(closest_comms) <- names(comm)
}
View(closest_comms)
# paths to comm
paths <- lapply(1:nrow(closest_comms),
FUN = function(i) comm - closest_comms[i, ])
paths <- do.call(rbind, paths)
paths
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
View(paths)
paths
data.frame(source = '1,8',
target = '1,5,7,8',
dist = 2,
`1` = 0, `5` = 1)
data.frame(source = '1,8',
target = '1,5,7,8',
dist = 2,
`'1'` = 0, `5` = 1)
paths
paths
set.seed(0)
target_comm <- data$community[100]
data <- data[-100, ]
data <- data[sample(1:nrow(data), size = 10), ]
paths <- closestPaths(target_comm, data$community)
paths2 <- paths
paths2$source <- '1,8'
paths2[, 4:11] <- c(0, 1, 1, 0, 0, 0, 0, 0)
paths2
paths
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
paths
paths2 <- paths
paths2$source <- '1,8'
paths2[, 4:11] <- c(0, 1, 1, 0, 0, 0, 0, 0)
paths2
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
View(paths)
path <- paths[i, ]
p <- 1
path <- paths[p, ]
path
traj <- paths[p, 4:ncol(paths)]
traj
traj <- colnames(traj)[traj[1, ] == 1]
traj
require(combinat)
install.packages('combinat')
permn(traj)
library(combinat)
permn(traj)
traj <- do.call(rbind(permn(traj))
traj <- do.call(rbind, permn(traj))
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
traj
View(traj)
traj_i <- traj[t, ]
t <- 1
traj_i <- traj[t, ]
traj_i
paths
rep(paths$source[p], length(traj_i + 1))
rep(paths$source[p], length(traj_i) + 1)
bg_i <- paste(rep(paths$source[p], length(traj_i) + 1), c('', traj_i))
bg_i
bg_i <- paste(rep(paths$source[p], length(traj_i) + 1), c('', traj_i), sep = ',')
bg_i
bg_i <- paste(rep(paths$source[p], length(traj_i)), c(traj_i), sep = ',')
bg_i
traj_i <- c('1', '5', '7', '8')
traj_i
paths$source[p] <- '2,3'
cumtraj_i <- sapply(1:length(traj_i), FUN = paste(traj_i[1:i], collapse = ','))
cumtraj_i <- sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ','))
cumtraj_i
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(paths$source[p], traj_i[1:i], collapse = ',')))
cumtraj_i
cumtraj_i <- orderName(paste(paths$source[p], cumtraj_i, sep = ','))
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i <- orderName(paste(paths$source[p], cumtraj_i, sep = ','))
cumtraj_i
traj_i
paths$source[p]
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i <- c(paths$source[p],
orderName(paste(paths$source[p], cumtraj_i, sep = ',')))
traj_i
cumtraj_i
cumtraj_i[-length(cumtraj_i)]
eps_i <- paste(cumtraj_i[-length(cumtraj_i)], traj_i, sep = '+')
eps_i
traj_i
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
eps_i
paths
traj
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
sapply(1:nrow(traj), FUN = function(t) {
traj_i <- traj[t, ]
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i <- c(paths$source[p],
orderName(paste(paths$source[p], cumtraj_i, sep = ',')))
eps_i <- paste(cumtraj_i[-length(cumtraj_i)], traj_i, sep = '+')
return(eps_i)
})
traj
lapply(1:nrow(traj), FUN = function(t) {
traj_i <- traj[t, ]
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i <- c(paths$source[p],
orderName(paste(paths$source[p], cumtraj_i, sep = ',')))
eps_i <- paste(cumtraj_i[-length(cumtraj_i)], traj_i, sep = '+')
return(eps_i)
})
traj
paths
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
eps
rm(list = ls())
### LIBRARIES
require(testthat)
require(MASS)
require(ggplot2)
require(gtools)
require(scales)
require(gridExtra)
require(tidyverse)
require(combinat)
run_tests <- FALSE # set to TRUE to run tests in every execution
### FUNCTIONS & TESTS
orderName <- function(community) {
# order community names with the form 'sp2,sp2,sp3,...' so that species consistently
# appear in alphabetical order
as.character(sapply(community,
FUN = function(s) paste(sort(strsplit(s, split = ',')[[1]]),
collapse = ',')))
}
string2matrix <- function(data) {
# takes a data frame with 2 columns, the first one containing community names
# (species present separated by commas with no spaces, e.g. 'sp1,sp2,sp3,...') and
# the second one community functions, and converts it to binary matrix format
species <- unique(unlist(sapply(data[, 1],
FUN = function(community) strsplit(community, split = ',')[[1]])))
data_out <- t(sapply(1:nrow(data),
FUN = function(i) as.numeric(species %in% strsplit(data[i, 1], split = ',')[[1]])))
colnames(data_out) <- species
data_out <- cbind(data_out, fun = data[, 2])
return(data_out)
}
matrix2string <- function(data) {
# inverse operation with respect to string2matrix
species <- colnames(data)[-ncol(data)]
communities <- sapply(1:nrow(data),
FUN = function(i) paste(species[data[i, -ncol(data)] == 1], collapse = ','))
communities <- orderName(communities)
return(data.frame(community = communities,
fun = data[, ncol(data)]))
}
if (run_tests) {
test_that('Name ordering',{
expect_equal(orderName('1,3,2'), '1,2,3')
expect_equal(orderName(c('B,C,A,F,D', 'y,x,z')), c('A,B,C,D,F', 'x,y,z'))
})
}
nSpecies <- function(community) {
# returns the number of species in a community (given in 'sp1,sp2,sp3,...' format)
# returns 0 if input is NA
as.numeric(sapply(community,
FUN = function(comm) {
if (is.na(comm)) return(0)
else return(length(strsplit(comm, split = ',')[[1]]))
}))
}
containsSpecies <- function(species, community) {
# returns TRUE if species is present in community, FALSE otherwise
return(sapply(community,
FUN = function(comm) species %in% strsplit(comm, split = ',')[[1]]))
}
makeGEdata <- function(data) {
# takes a mapping between community structures and functions and returns a data frame of species functional effects
# input data must be a data frame where he first column corresponds to genotype names and the second column corresponds to genotype fitness
# genotype names should be such that present mutations appear separated by commas with no spaces, e.g. 'sp1,sp2,sp3,...'
# use matrix2string() function to convert data to this format if needed
# name columns of data
colnames(data) <- c('community', 'f')
# order community names alphabetically
data[, 1] <- orderName(data[, 1])
# if there are multiple instances of a same genotype, take the average and print a warning
if(!all(table(data[, 1]) == 1)) {
warning(paste('Multiple instances of a same combination in input data set:\n',
paste(names(table(data[, 1]))[table(data[, 1]) > 1], collapse = '\n'),
'\nAveraging F to proceed.', sep = ''))
data <- aggregate(formula = f ~ community,
data = data,
FUN = mean)
}
# extract species names
species <- sort(unique(unlist(strsplit(data[, 1], split = ','))))
n_species <- length(species)
# functions as named array
f <- setNames(data[, 2], data[, 1])
# output: data frame where the effect of each species on a background community is isolated
ge_data <- do.call(rbind,
lapply(species,
FUN = function(sp) {
# fetch all communities in sample that contain species sp
knockins <- data$community[containsSpecies(sp, data$community)]
# backgrounds corresponding to those communities
backgrounds <- as.character(sapply(knockins,
FUN = function(x) {
x <- strsplit(x, split = ',')[[1]]
x <- x[x != sp]
x <- paste(x, collapse = ',')
return(x)
}))
# functions of backrounds and backgrounds + knock-ins
f_knockins <- as.numeric(f[knockins])
f_backgrounds <- as.numeric(f[backgrounds])
# build data frame
df <- data.frame(background = backgrounds,
knock_in = sp,
background_f = f_backgrounds,
d_f = f_knockins - f_backgrounds)
# keep only rows where the function of both the background and the knockin are known
df <- df[!is.na(df$background_f) & !is.na(df$d_f), ]
rownames(df) <- NULL
return(df)
}))
return(ge_data)
}
plotFEEs <- function(ge_data) {
# make dF-vs-F plots
p <-
ggplot(ge_data, aes(x = background_f, y = d_f)) +
geom_abline(slope = 0,
intercept = 0,
color = '#d1d3d4') +
geom_point(shape = 1,
cex = 2) +
geom_smooth(method = 'lm',
formula = y~x,
color = 'firebrick1',
se = F,
fullrange = T) +
scale_x_continuous(breaks = pretty_breaks(n = 3),
name = 'Function of ecological background [a.u.]') +
scale_y_continuous(breaks = pretty_breaks(n = 3),
name = 'dF [a.u.]') +
facet_wrap(~knock_in) +
theme_bw() +
theme(panel.grid = element_blank(),
strip.background = element_blank(),
strip.text = element_text(face = 'italic',
size = 10),
aspect.ratio = 0.6,
axis.text = element_text(size = 16),
axis.title = element_text(size = 18),
panel.border = element_blank(),
panel.background = element_blank(),
legend.position = 'none') +
annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size=0.5) +
annotate("segment", x=-Inf, xend=-Inf, y=-Inf, yend=Inf,size=0.5)
print(p)
return(p)
}
closestPaths <- function(target_comm, comm_list) {
# given a focal community (comm) and a list of other communities (comm_list), returns those in comm_list that are closest to comm (in terms of species addition/removal)
all_comms <- data.frame(community = c(target_comm, comm_list),
fun = NA)
all_comms <- string2matrix(all_comms)
comm <- all_comms[1, 1:(ncol(all_comms) - 1)]
comm_list <- all_comms[2:nrow(all_comms), 1:(ncol(all_comms) - 1)]
dist <- sapply(1:nrow(comm_list),
FUN = function(i) sum(abs(comm_list[i, ] - comm)))
which_min <- which(dist == min(dist))
closest_comms <- comm_list[which_min, ]
if (length(which_min) == 1) {
closest_comms <- matrix(closest_comms, nrow = 1)
colnames(closest_comms) <- names(comm)
}
# paths to comm
paths <- lapply(1:nrow(closest_comms),
FUN = function(i) comm - closest_comms[i, ])
paths <- do.call(rbind, paths)
sources <- matrix2string(cbind(as.data.frame(closest_comms), fun = NA))$community
# return info
return(cbind(source = sources, target = target_comm, dist = dist[which_min], as.data.frame(paths)))
}
### LOAD DATA FOR TESTING
data <- read.table('../pyoverdine_data/pyo_rep3.txt', header = T)
data <- rbind(data, data.frame(community = '', fun = 0))
ge_data <- makeGEdata(data)
fetchResiduals <- function(paths) {}
# fetch which residuals (epsilons) take part in a given path (from a source to a target community)
# accounts for every possible path order (e.g. i->j->k, j->i->k, k->i->j, ...)
# variable naming: eps_i(s) is named s+i (e.g. 'i,j+k', 'i,k+j', 'i,j,k+l', ...)
set.seed(0)
target_comm <- data$community[100]
data <- data[-100, ]
data <- data[sample(1:nrow(data), size = 100), ]
paths <- closestPaths(target_comm, data$community)
# paths2 <- paths
# paths2$source <- '1,8'
# paths2[, 4:11] <- c(0, 1, 1, 0, 0, 0, 0, 0)
# paths <- rbind(paths, paths2)
# rm(paths2)
paths
eps <- NULL
p <- 1
traj <- paths[p, 4:ncol(paths)]
traj
traj <- paths[p, 4:ncol(paths)]
traj <- colnames(traj)[abs(traj[1, ]) == 1]
traj
traj <- do.call(rbind, permn(traj))
traj
1:nrow(traj)
eps <- c(eps,
unlist(lapply(1:nrow(traj), FUN = function(t) {
traj_i <- traj[t, ]
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i <- c(paths$source[p],
orderName(paste(paths$source[p], cumtraj_i, sep = ',')))
eps_i <- paste(cumtraj_i[-length(cumtraj_i)], traj_i, sep = '+')
return(eps_i)
})))
eps
path
paths
paths
eps <- NULL
for (p in 1:nrow(paths)) {
traj <- paths[p, 4:ncol(paths)]
traj <- colnames(traj)[abs(traj[1, ]) == 1]
traj <- do.call(rbind, permn(traj))
eps <- c(eps,
unlist(lapply(1:nrow(traj), FUN = function(t) {
traj_i <- traj[t, ]
cumtraj_i <- orderName(sapply(1:length(traj_i), FUN = function(i) paste(traj_i[1:i], collapse = ',')))
cumtraj_i <- c(paths$source[p],
orderName(paste(paths$source[p], cumtraj_i, sep = ',')))
eps_i <- paste(cumtraj_i[-length(cumtraj_i)], traj_i, sep = '+')
return(eps_i)
})))
}
eps
paths
source("C:/Users/Juan/Desktop/ge_paper/eco_global_epist/scripts/ecoFunctions2.R", echo=TRUE)
fetchResiduals(paths)
paths
